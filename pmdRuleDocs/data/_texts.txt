The abstract class does not contain any abstract methodsAn abstract class suggests an incomplete implementation which is to be completed by subclasses implementing the abstract methodsIf the class is intended to be used as a base class only (not to be instantiated directly) a protected constructor can be provided prevent direct instantiation
Instantiation by way of private constructors from outside of the constructor's class often causes the generation of an accessorA factory method or non-privatization of the constructor can eliminate this situationThe generated class file is actually an interfaceIt gives the accessing class the ability to invoke a new hidden package scope constructor that takes the interface as a supplementary parameterThis turns a private constructor effectively into one with package scope and is challenging to discern
When accessing a private field / method from another class the Java compiler will generate a accessor methods with package-private visibilityThis adds overhead and to the dex method count on AndroidThis situation can be avoided by changing the visibility of the field / method from private to package-private
Constructors and methods receiving arrays should clone objects and store the copyThis prevents future changes from the user from affecting the original array
Avoid printStackTrace(); use a logger call instead
Reassigning values to incoming parameters is not recommendedUse temporary local variables instead
StringBuffers/StringBuilders can grow considerably and so may become a source of memory leaks if held within objects with long lifetimes
Application with hard-coded IP addresses can become impossible to deploy in some casesExternalizing IP adresses is preferable
Always check the return values of navigation methods (next previous first last) of a ResultSetIf the value return is 'false' it should be handled properly
Avoid constants in interfacesInterfaces should define types constants are implementation details better placed in classes or enumsSee Effective Java item 19
By convention the default label should be the last label in a switch statement
Reports loops that can be safely replaced with the foreach syntaxThe rule considers loops over lists arrays and iteratorsA loop is safe to replace if it only uses the index variable to access an element of the list or array only has one update statement and loops through *every* element of the list or array left to right
Whenever using a log level one should check if the loglevel is actually enabled or otherwise skip the associate String creation and manipulation
In JUnit 3 test suites are indicated by the suite() methodIn JUnit 4 suites are indicated through the @RunWith(Suite.class) annotation
In JUnit 3 the tearDown method was used to clean up all data entities required in running testsJUnit 4 skips the tearDown method and executes all methods annotated with @After after running each testJUnit 5 introduced @AfterEach and @AfterAll annotations to execute methods after each test or after all tests in the class respectively
In JUnit 3 the setUp method was used to set up all data entities required in running testsJUnit 4 skips the setUp method and executes all methods annotated with @Before before all testsJUnit 5 introduced @BeforeEach and @BeforeAll annotations to execute methods before each test or before all tests in the class respectively
In JUnit 3 the framework executed all methods which started with the word test as a unit testIn JUnit 4 only methods annotated with the @Test annotation are executedIn JUnit 5 one of the following annotations should be used for tests: @Test @RepeatedTest @TestFactory @TestTemplate or @ParameterizedTest
JUnit assertions should include an informative message - i.euse the three-argument version of assertEquals() not the two-argument version
Unit tests should not contain too many assertsMany asserts are indicative of a complex test for which it is harder to verify correctnessConsider breaking the test scenario into multiple shorter test scenariosCustomize the maximum number of assertions used by this Rule to suit your needsThis rule checks for JUnit4 JUnit5 and TestNG Tests as well as methods starting with "test"
JUnit tests should include at least one assertionThis makes the tests more robust and using assert with messages provide the developer a clearer idea of what the test does
In JUnit4 use the @Test(expected) annotation to denote tests that should throw exceptions
The use of implementation types (i.eHashSet) as object references limits your ability to use alternate implementations in the future as requirements changeWhenever available referencing objects by their interface types (i.e Set) provides much more flexibility
Exposing internal arrays to the caller violates object encapsulation since elements can be removed or replaced outside of the object that owns itIt is safer to return a copy of the array
Annotating overridden methods with @Override ensures at compile time that the method really overrides one which helps refactoring and clarifies intent
Java allows the use of several variables declaration of the same type on one lineHowever it can lead to quite messy codeThis rule looks for several declarations on the same line
Position literals first in comparisons if the second argument is null then NullPointerExceptions can be avoided they will just return false
Position literals first in comparisons if the second argument is null then NullPointerExceptions can be avoided they will just return false
Throwing a new exception from a catch block without passing the original exception into the new exception will cause the original stack trace to be lost making it difficult to debug effectively
Consider replacing Enumeration usages with the newer java.util.Iterato
Consider replacing Hashtable usage with the newer java.util.Map if thread safety is not required
Consider replacing Vector usages with the newer java.util.ArrayList if expensive thread-safe operations are not required
All switch statements should include a default option to catch any unspecified values
References to System.(out|err).print are usually intended for debugging purposes and can remain in the codebase even in production codeBy using a logger one can enable/disable this behaviour at will (and by priority) and avoid clogging the Standard out log
Avoid passing parameters to methods or constructors without actually referencing them in the method body
Avoid unused import statements to prevent unwanted dependenciesThis rule will also find unused on demand imports i.eimport com.foo.*
Detects when a local variable is declared and/or assigned but not used
Detects when a private field is declared and/or assigned a value but not used
Unused Private Method detects when a private method is declared but is unused
This rule detects JUnit assertions in object equalityThese assertions should be made by more specific methods like assertEquals
This rule detects JUnit assertions in object references equalityThese assertions should be made by more specific methods like assertNull assertNotNull
This rule detects JUnit assertions in object references equalityThese assertions should be made by more specific methods like assertSame assertNotSame
When asserting a value is the same as a literal or Boxed boolean use assertTrue/assertFalse instead of assertEquals
The isEmpty() method on java.util.Collection is provided to determine if a collection has any elementsComparing the value of size() to 0 does not convey intent as well as the isEmpty() method
Java 5 introduced the varargs parameter declaration for methods and constructorsThis syntactic sugar provides flexibility for users of these methods and constructors allowing them to avoid having to deal with the creation of an array
Abstract classes should be named 'AbstractXXX'
Each non-static class should declare at least one constructo
Avoid using dollar signs in variable/method/class/interface names
Avoid using final local variables turn them into field
Prefixing parameters by 'in' or 'out' pollutes the name of the parameters and reduces code readabilityTo indicate whether or not a parameter will be modify in a method its better to document method behavior with Javadoc
Do not use protected fields in final classes since they cannot be subclassedClarify your intent by using private or package access modifiers instead
Do not use protected methods in most final classes since they cannot be subclassedThis should only be allowed in final classes that extend other classes with protected methods (whose visibility cannot be reduced)Clarify your intent by using private or package access modifiers instead
Unnecessary reliance on Java Native Interface (JNI) calls directly reduces application portability and increases the maintenance burden
Methods that return boolean results should be named as predicate statements to denote thisI.e 'isReady()' 'hasValues()' 'canCommit()' 'willFail()' etcAvoid the use of the 'get' prefix for these methods
It is a good practice to call super() in a constructorIf super() is not called but another constructor (such as an overloaded constructor) is called this rule will not report it
Configurable naming conventions for type declarationsThis rule reports type declarations which do not match the regex that applies to their specific kind (e.genum or interface)Each regex can be configured through propertiesBy default this rule uses the standard Java naming convention (Pascal case) and reports utility class names not ending with 'Util'
To avoid mistakes if we want that a Method Constructor Field or Nested class have a default access modifier we must add a comment at the beginning of it's declarationBy default the comment must be /* default */ or /* package */ if you want another you have to provide a regular expression
Avoid negation within an "if" expression with an "else" clauseFor example rephrase: `if (x != y) diff(); else same();` as: `if (x == y) same(); else diff();`Most "if (x != y)" cases without an "else" are often return cases so consistent use of this rule makes the code easier to readAlso this resolves trivial ordering problems such as "does the error case go first?" or "does the common case go first?"
Enforce a policy for braces on control statementsIt is recommended to use braces on 'if ..else' statements and loop statements even if they are optionalThis usually makes the code clearer and helps prepare the future when you need to add another statementThat said this rule lets you control which statements are required to have braces via propertiesFrom 6.2.0 on this rule supersedes WhileLoopMustUseBraces ForLoopMustUseBraces IfStmtMustUseBraces and IfElseStmtMustUseBraces
Use explicit scoping instead of accidental usage of default package private levelThe rule allows methods and fields annotated with Guava's @VisibleForTesting
Avoid importing anything from the package 'java.lang'These classes are automatically imported (JLS 7.5.3)
Duplicate or overlapping import statements should be avoided
Empty or auto-generated methods in an abstract class should be tagged as abstractThis helps to remove their inapproprate usage by developers who should be implementing their own versions in the concrete subclasses
No need to explicitly extend Objec
Fields should be declared at the top of the class before any method declarations constructors initializers or inner classes
Configurable naming conventions for field declarationsThis rule reports variable declarations which do not match the regex that applies to their specific kind ---e.gconstants (static final) enum constant final fieldEach regex can be configured through propertiesBy default this rule uses the standard Java naming convention (Camel case) and uses the ALL_UPPER convention for constants and enum constants
Some for loops can be simplified to while loops this makes them more concise
Avoid using 'for' statements without using curly bracesIf the code formatting or indentation is lost then it becomes difficult to separate the code being controlled from the rest
Configurable naming conventions for formal parameters of methods and lambdasThis rule reports formal parameters which do not match the regex that applies to their specific kind (e.glambda parameter or final formal parameter)Each regex can be configured through propertiesBy default this rule uses the standard Java naming convention (Camel case)
Names for references to generic values should be limited to a single uppercase letter
Identical `catch` branches use up vertical space and increase the complexity of code without adding functionalityIt's better style to collapse identical branches into a single multi-catch branch
Avoid using if..else statements without using surrounding bracesIf the code formatting or indentation is lost then it becomes difficult to separate the code being controlled from the rest
Avoid using if statements without using braces to surround the code blockIf the code formatting or indentation is lost then it becomes difficult to separate the code being controlled from the rest
This rule finds Linguistic Naming AntipatternsIt checks for fields that are named as if they should be boolean but have a different typeIt also checks for methods that according to their name should return a boolean but don'tFurther it checks that getters return something and setters won'tFinally it checks that methods that start with "to" - so called transform methods - actually return something since according to their name they should convert or transform one object into anotherThere is additionally an option to check for methods that contain "To" in their name - which are also transform methodsHowever this is disabled by default since this detection is prone to false positivesFor more information see [Linguistic Antipatterns - What They Are and How Developers Perceive Them
The Local Home interface of a Session EJB should be suffixed by 'LocalHome'
The Local Interface of a Session EJB should be suffixed by 'Local'
A local variable assigned only once can be declared final
Configurable naming conventions for local variable declarations and other locally-scoped variablesThis rule reports variable declarations which do not match the regex that applies to their specific kind (e.gfinal variable or catch-clause parameter)Each regex can be configured through propertiesBy default this rule uses the standard Java naming convention (Camel case)
Fields formal arguments or local variable names that are too long can make the code difficult to follow
The EJB Specification states that any MessageDrivenBean or SessionBean should be suffixed by 'Bean'
A method argument that is never re-assigned within the method can be declared final
Configurable naming conventions for method declarationsThis rule reports method declarations which do not match the regex that applies to their specific kind (e.gJUnit test or native method)Each regex can be configured through propertiesBy default this rule uses the standard Java naming convention (Camel case)
Detects when a non-field has a name starting with 'm_'This usually denotes a field and could be confusing
Detects when a class or interface does not have a package definition
A method should have only one exit point and that should be the last statement in the method
Detects when a package definition contains uppercase characters
Checks for variables that are defined before they might be usedA reference is deemed to be premature if it is created right before a block of code that doesn't use it that also has the ability to return or throw an exception
Remote Interface of a Session EJB should not have a suffix
A Remote Home interface type of a Session EJB should be suffixed by 'Home'
Short Classnames with fewer than e.gfive characters are not recommended
Method names that are very short are not helpful to the reader
Fields local variables or parameter names that are very short are not helpful to the reader
Field names using all uppercase characters - Sun's Java naming conventions indicating constants - should be declared as final
If you overuse the static import feature it can make your program unreadable and unmaintainable polluting its namespace with all the static members you importReaders of your code (including you a few months after you wrote it) will not know which class a static member comes from (Sun 1.5 Language Guide)
Avoid the use of value in annotations when it's the only element
This rule detects when a constructor is not necessary; i.ewhen there is only one constructor and the constructor is identical to the default constructorThe default constructor should has same access modifier as the declaring classIn an enum type the default constructor is implicitly private
Import statements allow the use of non-fully qualified namesThe use of a fully qualified name which is covered by an import statement is redundantConsider using the non-fully qualified name
Avoid the creation of unnecessary local variable
Fields in interfaces and annotations are automatically `public static final` and methods are `public abstract`Classes interfaces or annotations nested in an interface or annotation are automatically `public static` (all nested interfaces and annotations are automatically static)Nested enums are automatically `static`For historical reasons modifiers which are implied by the context are accepted by the compiler but are superfluous
Avoid the use of unnecessary return statements
Useless parentheses should be remove
Look for qualified this usages in the same clas
A variable naming conventions rule - customize this to your likingCurrently it checks for final variables that should be fully capitalized and non-final variables that should not include underscores
Avoid using 'while' statements without using braces to surround the code blockIf the code formatting or indentation is lost then it becomes difficult to separate the code being controlled from the rest
If an abstract class does not provides any methods it may be acting as a simple data container that is not meant to be instantiatedIn this case it is probably better to use a private or protected constructor in order to prevent instantiation than make the class misleadingly abstract
Avoid catching generic exceptions such as NullPointerException RuntimeException Exception in try-catch bloc
Avoid creating deeply nested if-then statements since they are harder to read and error-prone to maintain
Catch blocks that merely rethrow a caught exception only add to code size and runtime complexity
Catch blocks that merely rethrow a caught exception wrapped inside a new instance of the same type only add to code size and runtime complexity

Avoid throwing certain exception typesRather than throw a raw RuntimeException Throwable Exception or Error use a subclassed exception or error instead
A class with only private constructors should be final unless the private constructor is invoked by a inner class
Sometimes two consecutive 'if' statements can be consolidated by separating their conditions with a boolean short-circuit operator
This rule counts the number of unique attributes local variables and return types within an objectA number higher than the specified threshold can indicate a high degree of coupling

Data Classes are simple data holders which reveal most of their state and without complex functionalityThe lack of functionality may indicate that their behaviour is defined elsewhere which is a sign of poor data-behaviour proximityBy directly exposing their internals Data Classes break encapsulation and therefore reduce the system's maintainability and understandabilityMoreover classes tend to strongly rely on their data representation which makes for a brittle designRefactoring a Data Class should focus on restoring a good data-behaviour proximityIn most cases that means moving the operations defined on the data back into the classIn some other cases it may make sense to remove entirely the class and move the data into the former client classes
Errors are system exceptionsDo not extend them
Using Exceptions as form of flow control is not recommended as they obscure true exceptions when debuggingEither add the necessary validation or use an alternate control structure
Excessive class file lengths are usually indications that the class may be burdened with excessive responsibilities that could be provided by external classes or functionsIn breaking these methods apart the code becomes more manageable and ripe for reuse
A high number of imports can indicate a high degree of coupling within an objectThis rule counts the number of unique imports and reports a violation if the count is above the user-specified threshold
When methods are excessively long this usually indicates that the method is doing more than its name/signature might suggestThey also become challenging for others to digest since excessive scrolling causes readers to lose focusTry to reduce the method length by creating helper methods and removing any copy/pasted code
Methods with numerous parameters are a challenge to maintain especially if most of them share the same datatypeThese situations usually denote the need for new objects to wrap the numerous parameters
Classes with large numbers of public methods and attributes require disproportionate testing efforts since combinational side effects grow rapidly and increase riskRefactoring these classes into smaller ones not only increases testability and reliability but also allows new variations to be developed easily
If a final field is assigned to a compile-time constant it could be made static thus saving overhead in each object at runtime
The God Class rule detects the God Class design flaw using metricsGod classes do too many things are very big and overly complexThey should be split apart to be more object-orientedThe rule uses the detection strategy described in "Object-Oriented Metrics in Practice"The violations are reported against the entire classSee also the references: Michele Lanza and Radu MarinescuObject-Oriented Metrics in Practice: Using Software Metrics to Characterize Evaluate and Improve the Design of Object-Oriented SystemsSpringer Berlin 1 edition October 2006Page 80
Identifies private fields whose values never change once they are initialized either in the declaration of the field or by a constructorThis helps in converting existing classes to becoming immutable ones
The Law of Demeter is a simple rule that says "only talk to friends"It helps to reduce coupling between classes or objects
Use opposite operator instead of negating the whole expression with a logic complement operator
Avoid using classes from the configured package hierarchy outside of the package hierarchy except when using one of the configured allowed classes
Complexity directly affects maintenance costs is determined by the number of decision points in a method plus one for the method entryThe decision points include 'if' 'while' 'for' and 'case labels' callsGenerally numbers ranging from 1-4 denote low complexity 5-7 denote moderate complexity 8-10 denote high complexity and 11+ is very high complexityModified complexity treats switch statements as a single decision point
This rule uses the NCSS (Non-Commenting Source Statements) algorithm to determine the number of lines of code for a given constructorNCSS ignores comments and counts actual statementsUsing this algorithm lines of code that are split are counted as one
This rule uses the NCSS (Non-Commenting Source Statements) metric to determine the number of lines of code in a class method or constructorNCSS ignores comments blank lines and only counts actual statementsFor more details on the calculation see the documentation of the [NCSS metric](/pmd_java_metrics_index.html#non-commenting-source-statements-ncss)
This rule uses the NCSS (Non-Commenting Source Statements) algorithm to determine the number of lines of code for a given methodNCSS ignores comments and counts actual statementsUsing this algorithm lines of code that are split are counted as one
This rule uses the NCSS (Non-Commenting Source Statements) algorithm to determine the number of lines of code for a given typeNCSS ignores comments and counts actual statementsUsing this algorithm lines of code that are split are counted as one
The NPath complexity of a method is the number of acyclic execution paths through that methodWhile cyclomatic complexity counts the number of decision points in a method NPath counts the number of full paths from the beginning to the end of the block of the methodThat metric grows exponentially as it multiplies the complexity of statements in the same blockFor more details on the calculation see the documentation of the [NPath metric](/pmd_java_metrics_index.html#npath-complexity-npath)A threshold of 200 is generally considered the point where measures should be taken to reduce complexity and increase readability
A method/constructor shouldn't explicitly throw the generic java.lang.Exception since it is unclear which exceptions that can be thrown from the methodsIt might be difficult to document and understand such vague interfacesUse either a class derived from RuntimeException or a checked exception

Avoid negation in an assertTrue or assertFalse testFor example rephrase: assertTrue(!expr); as: assertFalse(expr)
Avoid unnecessary comparisons in boolean expressions they serve no purpose and impacts readability
Avoid unnecessary if-then-else statements when returning a booleanThe result of the conditional test can be returned instead
No need to check for null before an instanceof; the instanceof keyword returns false when given a null argument
Fields whose scopes are limited to just single methods do not rely on the containing object to provide them to other methodsThey may be better implemented as local variables within those methods
Complexity directly affects maintenance costs is determined by the number of decision points in a method plus one for the method entryThe decision points include 'if' 'while' 'for' and 'case labels' callsGenerally numbers ranging from 1-4 denote low complexity 5-7 denote moderate complexity 8-10 denote high complexity and 11+ is very high complexity
A high ratio of statements to labels in a switch statement implies that the switch statement is overloadedConsider moving the statements into new methods or creating subclasses based on the switch variable
Classes that have too many fields can become unwieldy and could be redesigned to have fewer fields possibly through grouping related fields in new objectsFor example a class with individual city/state/zip fields could park them within a single Address field
A class with too many methods is probably a good suspect for refactoring in order to reduce its complexity and find a way to have more fine grained objects
The overriding method merely calls the same method defined in a superclass
When you write a public method you should be thinking in terms of an APIIf your method is public it means other class will use it therefore you want (or need) to offer a comprehensive and evolutive APIIf you pass a lot of information as a simple series of Strings you may think of using an Object to represent all those informationYou'll get a simpler API (such as doWork(Workload workload) rather than a tedious series of Strings) and more importantly if you need at some point to pass extra data you'll be able to do so by simply modifying or extending Workload without any modification to your API
For classes that only have static methods consider making them utility classesNote that this doesn't apply to abstract classes since their subclasses may well include non-static methodsAlso if you want this class to be a utility class remember to add a private constructor to prevent instantiation(Note that this use was known before PMD 5.1.0 as UseSingleton)
A rule for the politically correct..we don't want to offend anyone
Denotes whether comments are required (or unwanted) for specific language elements
Determines whether the dimensions of non-header comments found are within the specified limits
Uncommented Empty Constructor finds instances where a constructor does not contain statements but there is no commentBy explicitly commenting empty constructors it is easier to distinguish between intentional (commented) and unintentional empty constructors
Uncommented Empty Method Body finds instances where a method body does not contain statements but there is no commentBy explicitly commenting empty method bodies it is easier to distinguish between intentional (commented) and unintentional empty methods
Avoid assignments in operands; this can make code more complicated and harder to read
Identifies a possible unsafe usage of a static field
Methods such as getDeclaredConstructors() getDeclaredConstructor(Class[]) and setAccessible() as the interface PrivilegedAction allow for the runtime alteration of variable class or method visibility even if they are privateThis violates the principle of encapsulation
Use of the term 'assert' will conflict with newer versions of Java since it is a reserved word
Using a branching statement as the last part of a loop may be a bug and/or is confusingEnsure that the usage is not a bug or consider using another approach
The method Object.finalize() is called by the garbage collector on an object when garbage collection determines that there are no more references to the objectIt should not be invoked by application logicNote that Oracle has declared Object.finalize() as deprecated since JDK 9
Code should never throw NullPointerExceptions under normal circumstancesA catch block may hide the original error causing other more subtle problems later on
Catching Throwable errors is not recommended since its scope is very broadIt includes runtime issues such as OutOfMemoryError that should be exposed and managed separately
One might assume that the result of "new BigDecimal(0.1)" is exactly equal to 0.1 but it is actually equal to .1000000000000000055511151231257827021181583404541015625This is because 0.1 cannot be represented exactly as a double (or as a binary fraction of any finite length)Thus the long value that is being passed in to the constructor is not exactly equal to 0.1 appearances notwithstandingThe (String) constructor on the other hand is perfectly predictable: 'new BigDecimal("0.1")' is exactly equal to 0.1 as one would expectTherefore it is generally recommended that the (String) constructor be used in preference to this one
Code containing duplicate String literals can usually be improved by declaring the String as a constant field
Use of the term 'enum' will conflict with newer versions of Java since it is a reserved word
It can be confusing to have a field name with the same name as a methodWhile this is permitted having information (field) and actions (method) is not clear namingDevelopers versed in Smalltalk often prefer this approach as the methods denote accessor methods
It is somewhat confusing to have a field name matching the declaring class nameThis probably means that type and/or field names should be chosen more carefully
Each caught exception type should be handled in its own catch clause
Avoid using hard-coded literals in conditional statementsBy declaring them as static variables or private members with descriptive names maintainability is enhancedBy default the literals "-1" and "0" are ignoredMore exceptions can be defined with the property "ignoreMagicNumbers"
Statements in a catch block that invoke accessors on the exception without using the information only add to code sizeEither remove the invocation or use the return result
The use of multiple unary operators may be problematic and/or confusingEnsure that the intended usage is not a bug or consider simplifying the expression
Integer literals should not start with zero since this denotes that the rest of literal will be interpreted as an octal value
Avoid equality comparisons with Double.NaNDue to the implicit lack of representation precision when comparing floating point numbers these are likely to cause logic errors
If a class is a bean or is referenced by a bean directly or indirectly it needs to be serializableMember variables need to be marked as transient static or have accessor methods in the classMarking variables as transient is the safest and easiest modificationAccessor methods should follow the Java naming conventions i.efor a variable named foo getFoo() and setFoo() accessor methods should be provided
or vice versa
Super should be called at the start of the meth
Super should be called at the end of the metho
The skip() method may skip a smaller number of bytes than requestedCheck the returned value to find out if it was the case or not
When deriving an array of a specific class from your Collection one should provide an array of the same class as the parameter of the toArray() methodDoing otherwise you will will result in a ClassCastException
The java Manual says "By convention classes that implement this interface should override Object.clone (which is protected) with a public method.
The method clone() should only be implemented if the class implements the Cloneable interface with the exception of a final method that only throws CloneNotSupportedExceptionThe rule can also detect if the class implements or extends a Cloneable class
If a class implements cloneable the return type of the method clone() must be the class nameThat way the caller of the clone method doesn't need to cast the returned clone to the correct typeNote: This is only possible with Java 1.5 or higher
The method clone() should throw a CloneNotSupportedException
Ensure that resources (like Connection Statement and ResultSet objects) are always closed after use
Use equals() to compare object references; avoid comparing them with ==
Calling overridable methods during construction poses a risk of invoking methods on an incompletely constructed object and can be difficult to debugIt may leave the sub-class unable to construct its superclass or forced to replicate the construction process completely within itself losing the ability to call super()If the default constructor contains a call to an overridable method the subclass may be completely uninstantiableNote that this includes method calls throughout the control flow graph - i.eif a constructor Foo() calls a private method bar() that calls a public method buz() this denotes a problem
The dataflow analysis tracks local definitions undefinitions and references to variables on different paths on the data flowFrom those informations there can be found various problems1UR - Anomaly: There is a reference to a variable that was not defined beforeThis is a bug and leads to an error2DU - Anomaly: A recently defined variable is undefinedThese anomalies may appear in normal source text3DD - Anomaly: A recently defined variable is redefinedThis is ominous but don't have to be a bug
Calls to System.gc() Runtime.getRuntime().gc() and System.runFinalization() are not advisedCode should have the same behavior whether the garbage collection is disabled using the option -Xdisableexplicitgc or notMoreover "modern" jvms do a very good job handling garbage collectionsIf memory usage issues unrelated to memory leaks develop within an application it should be dealt with JVM options rather than within the code itself
Web applications should not call System.exit() since only the web container or the application server should stop the JVMThis rule also checks for the equivalent call Runtime.getRuntime().exit()
Extend Exception or RuntimeException instead of Throwable
Use Environment.getExternalStorageDirectory() instead of "/sdcard
Throwing exceptions within a 'finally' block is confusing since they may mask other exceptions or code defectsNote: This is a PMD implementation of the Lint4j rule "A throw in a finally block
Avoid importing anything from the 'sun.*' packagesThese packages are not portable and are likely to change
Don't use floating point for loop indicesIf you must use floating point use double unless you're certain that float provides enough precision and you have a compelling performance need (space or time)
Empty Catch Block finds instances where an exception is caught but nothing is doneIn most circumstances this swallows an exception which should either be acted on or reported
Empty finalize methods serve no purpose and should be removedNote that Oracle has declared Object.finalize() as deprecated since JDK 9
Empty finally blocks serve no purpose and should be removed
Empty If Statement finds instances where a condition is checked but nothing is done about it
Empty initializers serve no purpose and should be removed
Empty block statements serve no purpose and should be removed
An empty statement (or a semicolon by itself) that is not used as the sole body of a 'for' or 'while' loop is probably a bugIt could also be a double semicolon which has no purpose and should be removed
Empty switch statements serve no purpose and should be removed
Empty synchronized blocks serve no purpose and should be removed
Avoid empty try blocks - what's the point
Empty While Statement finds all instances where a while statement does nothingIf it is a timing loop then you should use Thread.sleep() for it; if it is a while loop that does a lot in the exit expression rewrite it to make it clearer
Tests for null should not use the equals() methodThe '==' operator should be used instead
If the finalize() is implemented its last action should be to call super.finalizeNote that Oracle has declared Object.finalize() as deprecated since JDK 9
If the finalize() is implemented it should do something besides just calling super.finalize()Note that Oracle has declared Object.finalize() as deprecated since JDK 9
Methods named finalize() should not have parametersIt is confusing and most likely an attempt to overload Object.finalize()It will not be called by the VMNote that Oracle has declared Object.finalize() as deprecated since JDK 9
When overriding the finalize() the new method should be set as protectedIf made public other classes may invoke it at inappropriate timesNote that Oracle has declared Object.finalize() as deprecated since JDK 9
Avoid idempotent operations - they have no effect
There is no need to import a type that lives in the same package
Avoid instantiating an object just to call getClass() on it; use the .class public member instead
Check for messages in slf4j loggers with non matching number of arguments and placeholders
Avoid jumbled loop incrementers - its usually a mistake and is confusing even if intentional
Some JUnit framework methods are easy to misspell
The suite() method in a JUnit test needs to be both public and static
In most cases the Logger reference can be declared as static and final
Non-constructor methods should not have the same name as the enclosing class
The null check here is misplacedIf the variable is null a NullPointerException will be thrownEither the check is useless (the variable will never be "null") or it is incorrect
Switch statements without break or return statements for each case option may indicate problematic behaviourEmpty cases are ignored as these indicate an intentional fall-through
Serializable classes should provide a serialVersionUID fieldThe serialVersionUID field is also needed for abstract base classesEach individual class in the inheritance chain needs an own serialVersionUID fieldSee also [Should an abstract class have a serialVersionUID
A class that has private constructors and does not have any static methods or fields cannot be used
Normally only one logger is used in each class
A non-case label (e.ga named break/continue label) was present in a switch statementThis legal but confusingIt is easy to mix up the case labels and the non-case labels
A non-static initializer block will be called any time a constructor is invoked (just prior to invoking the constructor)While this is a valid language construct it is rarely used and is confusing
Assigning a "null" to a variable (outside of its declaration) is usually bad formSometimes this type of assignment is an indication that the programmer doesn't completely understand what is going on in the codeNOTE: This sort of assignment may used in some cases to dereference objects and encourage garbage collection
Override both public boolean Object.equals(Object other) and public int Object.hashCode() or override neitherEven if you are inheriting a hashCode() from a parent class consider implementing hashCode and explicitly delegating to your superclass
Object clone() should be implemented with super.clone()
A logger should normally be defined private static final and be associated with the correct classPrivate final Log log; is also allowed for rare cases where loggers need to be passed around with the restriction that the logger needs to be passed into the constructor
For any method that returns an array it is a better to return an empty array rather than a null referenceThis removes the need for null checking all results and avoids inadvertent NullPointerExceptions
Avoid returning from a finally block this can discard exceptions
Be sure to specify a Locale when creating SimpleDateFormat instances to ensure that locale-appropriate formatting is used
Some classes contain overloaded getInstanceThe problem with overloaded getInstance methods is that the instance created using the overloaded method is not cached and so for each call and new objects will be created for every invocation
Some classes contain overloaded getInstanceThe problem with overloaded getInstance methods is that the instance created using the overloaded method is not cached and so for each call and new objects will be created for every invocation
According to the J2EE specification an EJB should not have any static fields with write accessHowever static read-only fields are allowedThis ensures proper behavior especially when instances are distributed by the container on several JREs
Individual character values provided as initialization arguments will be converted into integersThis can lead to internal buffer sizes that are larger than expectedSome examples: ``` new StringBuffer() // 16 new StringBuffer(6) // 6 new StringBuffer("hello world") // 11 + 16 = 27 new StringBuffer('A') // chr(A) = 65 new StringBuffer("A") // 1 + 16 = 17 new StringBuilder() // 16 new StringBuilder(6) // 6 new StringBuilder("hello world") // 11 + 16 = 27 new StringBuilder('C') // chr(C) = 67 new StringBuilder("A") // 1 + 16 = 17 ``
The method name and parameter number are suspiciously close to equals(Object) which can denote an intention to override the equals(Object) method
The method name and return type are suspiciously close to hashCode() which may denote an intention to override the hashCode() method
A suspicious octal escape sequence was found inside a String literalThe Java language specification (section 3.10.6) says an octal escape sequence inside a literal String shall consist of a backslash followed by: OctalDigit | OctalDigit OctalDigit | ZeroToThree OctalDigit OctalDigit Any octal escape sequence followed by non-octal digits can be confusing e.g"\038" is interpreted as the octal escape sequence "\03" followed by the literal character "8"
Test classes end with the suffix TestHaving a non-test class with that name is not a good practice since most people will assume it is a test caseTest classes have test methods named testXXX
Do not use "if" statements whose conditionals are always true or always false
A JUnit test assertion with a boolean literal is unnecessary since it always will evaluate to the same thingConsider using flow control (in case of assertTrue(false) or similar) or simply removing statements like assertTrue(true) and assertFalse(false)If you just want a test to halt after finding an error use the fail() method and provide an indication message of why it did
Using equalsIgnoreCase() is faster than using toUpperCase/toLowerCase().equals(
Avoid the use temporary objects when converting primitives to StringsUse the static conversion methods on the wrapper classes instead
After checking an object reference for null you should invoke equals() on that object rather than passing it to another object's equals() method
To make sure the full stacktrace is printed out use the logging statement with two arguments: a String and a Throwable
Using '==' or '!=' to compare strings only works if intern version is used on both sidesUse the equals() method instead
An operation on an Immutable object (String BigDecimal or BigInteger) won't change the object itself since the result of the operation is a new objectTherefore ignoring the operation result is an error
When doing String.toLowerCase()/toUpperCase() conversions use Locales to avoids problems with languages that have unusual conventions i.eTurkish
In J2EE the getClassLoader() method might not work as expectedUse Thread.currentThread().getContextClassLoader() instead
Method-level synchronization can cause problems when new code is added to the methodBlock-level synchronization helps to ensure that only the code that needs synchronization gets it
Avoid using java.lang.ThreadGroup; although it is intended to be used in a threaded environment it contains methods that are not thread-safe
Use of the keyword 'volatile' is generally used to fine tune a Java application and therefore requires a good expertise of the Java Memory ModelMoreover its range of action is somewhat misknownTherefore the volatile keyword should not be used for maintenance purpose and portability
The J2EE specification explicitly forbids the use of threads
Explicitly calling Thread.run() method will execute in the caller's thread of controlInstead call Thread.start() for the intended behavior
Partially created objects can be returned by the Double Checked Locking pattern when used in JavaAn optimizing JRE may assign a reference to the baz variable before it calls the constructor of the object the reference points toNote: With Java 5 you can make Double checked locking work if you declare the variable to be `volatile`
Non-thread safe singletons can result in bad state changesEliminate static singletons if possible by instantiating the object directlyStatic singletons are usually not needed as only a single instance exists anywayOther possible fixes are to synchronize the entire method or to use an [initialize-on-demand holder class] Refrain from using the double-checked locking patternThe Java Memory Model doesn't guarantee it to work unless the variable is declared as `volatile` adding an uneeded performance penalty
SimpleDateFormat instances are not synchronizedSun recommends using separate format instances for each threadIf multiple threads must access a static formatter the formatter must be synchronized either on method or block level
Since Java5 brought a new implementation of the Map designed for multi-threaded access you can perform efficient map reads without blocking other threads
Thread.notify() awakens a thread monitoring the objectIf more than one thread is monitoring then only one is chosenThe thread chosen is arbitrary; thus its usually safer to call notifyAll() instead
The conversion of literals to strings by concatenating them with empty strings is inefficientIt is much better to use one of the type-specific toString() methods instead
Avoid concatenating characters as strings in StringBuffer/StringBuilder.append methods
Instead of manually copying data between two arrays use the efficient Arrays.copyOf or System.arraycopy method instead
The FileInputStream and FileOutputStream classes contains a finalizer method which will cause garbage collection pausesSee for detailsThe FileReader and FileWriter constructors instantiate FileInputStream and FileOutputStream again causing garbage collection issues while finalizer methods are called* Use `Files.newInputStream(Paths.get(fileName))` instead of `new FileInputStream(fileName)`* Use `Files.newOutputStream(Paths.get(fileName))` instead of `new FileOutputStream(fileName)`* Use `Files.newBufferedReader(Paths.get(fileName))` instead of `new FileReader(fileName)`* Use `Files.newBufferedWriter(Paths.get(fileName))` instead of `new FileWriter(fileName)`
New objects created within loops should be checked to see if they can created outside them and reused
Java uses the 'short' type to reduce memory usage not to optimize calculationIn fact the JVM does not have any arithmetic capabilities for the short type: the JVM must convert the short into an int do the proper calculation and convert the int back to a shortThus any storage gains found through use of the 'short' type may be offset by adverse impacts on performance
Don't create instances of already existing BigInteger (BigInteger.ZERO BigInteger.ONE) and for Java 1.5 onwards BigInteger.TEN and BigDecimal (BigDecimal.ZERO BigDecimal.ONE BigDecimal.TEN
Avoid instantiating Boolean objects; you can reference Boolean.TRUE Boolean.FALSE or call Boolean.valueOf() insteadNote that new Boolean() is deprecated since JDK 9 for that reason
Calling new Byte() causes memory allocation that can be avoided by the static Byte.valueOf()It makes use of an internal cache that recycles earlier instances making it more memory efficientNote that new Byte() is deprecated since JDK 9 for that reason
Consecutive calls to StringBuffer/StringBuilder .append should be chained reusing the target objectThis can improve the performance by producing a smaller bytecode reducing overhead and improving inliningA complete analysis can be foun
Consecutively calling StringBuffer/StringBuilder.append(...) with literals should be avoidedSince the literals are constants they can already be combined into a single String literal and this String can be appended in a single method call

Avoid concatenating non-literals in a StringBuffer constructor or append() since intermediate buffers will need to be be created and destroyed by the JVM
Failing to pre-size a StringBuffer or StringBuilder properly could cause it to re-size many times during runtimeThis rule attempts to determine the total number the characters that are actually passed into StringBuffer.append() but represents a best guess "worst case" scenarioAn empty StringBuffer/StringBuilder constructor initializes the object to 16 charactersThis default is assumed if the length of the constructor can not be determined
Calling new Integer() causes memory allocation that can be avoided by the static Integer.valueOf()It makes use of an internal cache that recycles earlier instances making it more memory efficientNote that new Integer() is deprecated since JDK 9 for that reason
Calling new Long() causes memory allocation that can be avoided by the static Long.valueOf()It makes use of an internal cache that recycles earlier instances making it more memory efficientNote that new Long() is deprecated since JDK 9 for that reason
Calls to a collection's `toArray(E[])` method should specify a target array of zero sizeThis allows the JVM to optimize the memory allocation and copying as much as possiblePrevious versions of this rule (pre PMD 6.0.0) suggested the opposite but current JVM implementations perform always better when they have full control over the target arrayAnd allocation an array via reflection is nowadays as fast as the direct allocationSee also [Arrays of Wisdom of the Ancients] Note: If you don't need an array of the correct type then the simple `toArray()` method without an array is faster but returns only an array of type `Object[]`
Java will initialize fields with known default values so any explicit initialization of those same defaults is redundant and results in a larger class file (approximately three additional bytecode instructions per field)
Since it passes in a literal of length 1 calls to (string).startsWith can be rewritten using (string).charAt(0) at the expense of some readability
Calling new Short() causes memory allocation that can be avoided by the static Short.valueOf()It makes use of an internal cache that recycles earlier instances making it more memory efficientNote that new Short() is deprecated since JDK 9 for that reason
Avoid instantiating String objects; this is usually unnecessary since they are immutable and can be safely shared
Avoid calling toString() on objects already known to be string instances; this is unnecessary
Switch statements are intended to be used to support complex branching behaviourUsing a switch for only a few cases is ill-advised since switches are not as easy to understand as if-then statementsIn these cases use the if-then statement to increase code readability
Most wrapper classes provide static conversion methods that avoid the need to create intermediate objects just to create the primitive formsUsing these avoids the cost of creating objects that also need to be garbage-collected later
ArrayList is a much better Collection implementation than Vector if thread-safe operation is not required

Use String.indexOf(char) when checking for the index of a single character; it executes faster
No need to call String.valueOf to append to a string; just use the valueOf() argument directly
The use of the '+=' operator for appending strings causes the JVM to create and use an internal StringBufferIf a non-trivial number of these concatenations are being used then the explicit use of a StringBuilder or threadsafe StringBuffer is recommended to avoid this
Use StringBuffer.length() to determine StringBuffer length rather than using StringBuffer.toString().equals("") or StringBuffer.toString().length() == ..
Do not use hard coded values for cryptographic operationsPlease store keys outside of source code
Do not use hard coded initialization vector in cryptographic operationsPlease use a randomly generated IV